from shiny import App, render, ui, reactive
import shinyswatch
import requests
import openai


# Canvas Configuration
#CANVAS_API_URL = 'https://canvas.instructure.com/api/v1/'
#CANVAS_API_TOKEN = '*****************'
#COURSE_ID = '******'

#API_KEY = "***********************************A"
#openai.api_key = API_KEY
#model_id = 'gpt-3.5-turbo'

quiz_data = {
    "quiz": {
        "title": "Submit Q & True A",
        "description": "Quiz generated by ChatGPT based on class material.",
        "quiz_type": "assignment",
        "points_possible": 3,
        "allowed_attempts": 1,
        "question_count": 3,
        "time_limit": 60,
        "published": True
    }
}


CHOICES = ['Request Q & A','Submit Q & True A','Submit Q']

app_ui = ui.page_fluid(
    shinyswatch.theme.superhero(),
    ui.panel_title('Quiz Builder'),
    ui.navset_tab(
        ui.nav("Put your API code here",       
            ui.HTML('<br>'),            
            ui.input_text("textin_apikey", "", placeholder="Enter Your GPT API Key"),
            ui.input_text("textin_canvas_site", "", placeholder="Enter Your Canvas API Key"),
            ui.input_text("textin_COURSE_ID", "", placeholder="Enter Your COURSE_ID"),
            #ui.input_action_button('action_import','Import to Canvas')
        ),
        ui.nav("Generate Your Quiz",
            ui.HTML('<br>'),
            ui.input_radio_buttons(id='checkboxin',label='Select options',choices=CHOICES,selected=[0,0,0]),
            ui.input_text_area("textin1", "Text input", placeholder="Enter text"),
            ui.panel_conditional("input.checkboxin==='Request Q & A'",                               
                                 ui.input_numeric(id='numin',label='Number of Questions',value=10)),
            ui.output_text_verbatim("txt"),
            ui.input_action_button('action_generate','Generate Quiz'), ui.HTML('<br>'), ui.HTML('<br>'),
        ),
        
    ),

)

def server(input, output, session):
    
    model_id = 'gpt-3.5-turbo'

    def ChatGPT_conversation(conversation):
        response = openai.ChatCompletion.create(
            model=model_id,
            messages=conversation,
        )
        conversation.append({'role': response.choices[0].message.role, 'content': response.choices[0].message.content})
        return conversation

    @output
    @render.text
    def txt():
        return input.textin1()

    @reactive.Effect()
    @reactive.event(input.checkboxin,)
    def choices():
        ui.panel_conditional("input.checkboxin==='Request Q & A'",                                  
                                 ui.update_text("textin1", label= "Describe the specific topics for this quiz.")
        )
        x = input.checkboxin()
        print(x)
        if x == CHOICES[0]:
            labelout = 'Describe the general field of study for this quiz.'
        if x == CHOICES[1]:
            labelout = 'Enter your questions and the corresponding correct answers.'
        if x == CHOICES[2]:
            labelout = 'Enter your questions.'
        ui.update_select(
            "textin1",
            label=labelout
        )


    @reactive.Effect()
    @reactive.event(input.action_generate)
    def canvas():       
        CANVAS_API_URL = 'https://canvas.instructure.com/api/v1/'
        CANVAS_API_TOKEN = input.textin_canvas_site()
        COURSE_ID = input.textin_COURSE_ID()

        API_KEY = input.textin_apikey()
        openai.api_key = API_KEY

        headers_canvas = {
        'Authorization': f'Bearer {CANVAS_API_TOKEN}',
        'Content-Type': 'application/json'
        }

        x = input.checkboxin() 
        if x == CHOICES[0]:
            prompt = f"Based on {input.textin1()} field, generate {input.numin()} quiz questions, each with 4 choices, use [correct] to stated the correct answer after the choice. The format should same as this example: (1. What is the purpose of Value at Risk (VaR) in finance risk management? a)[correct] To measure the potential loss in value of a portfolio of assets based on a specified confidence level b) To identify the level of diversification in a portfolio to mitigate risk c) To calculate the expected returns of a financial investment d) To evaluate the liquidity risk associated with a particular asset class), but don't let all the correct answer is a, no more other words."
        if x == CHOICES[1]:
            prompt = f"Read those quiz questions and the corresponding correct answers: {input.textin1()}, for each question, make other three wrong choices, randomly put the correct answer as choices a/b/c/d, use [correct] to stated the correct answer after the choice. format should same as this example: (1. (question) a)[correct] (choices a) b) (choices b) c) (choices c) d) (choices d)), after completed. return those questions back to me. no more other words."    
        if x == CHOICES[2]:
            prompt = f"Read those quiz questions and make one correct answer and three wrong answer for each questions: {input.textin1()}, use [correct] to stated the correct answer after the choice. The format should same as this example: (1. What is the purpose of Value at Risk (VaR) in finance risk management? a)[correct] To measure the potential loss in value of a portfolio of assets based on a specified confidence level b) To identify the level of diversification in a portfolio to mitigate risk c) To calculate the expected returns of a financial investment d) To evaluate the liquidity risk associated with a particular asset class), but don't let all the correct answer is a, no more other words."                

        conversation = []
        conversation.append({'role': 'user', 'content': prompt})
        conversation = ChatGPT_conversation(conversation)
        responses = ('{0}: {1}\n'.format(conversation[-1]['role'].strip(), conversation[-1]['content'].strip()))
        print(f'response : {responses}')
        
        response = requests.post(f'{CANVAS_API_URL}courses/{COURSE_ID}/quizzes', headers=headers_canvas, json=quiz_data)
        quiz_id = response.json()['id']
        
        parsed_questions = []
        # Parse the generated questions
        questions = responses.split('\n\n') # Split by two newlines to separate questions
        questions = [questions[0].replace('assistant: ', '')] + questions[1:] 
        print(f'questions : {questions}')

        for question in questions:
            if not question.strip():  # Skip empty strings
                continue
            lines = question.split('\n')
            
            print(f'lines : {lines}')
            question_text = lines[0]   
            options = lines[1:]
            
            parsed_questions.append({
                'text': question_text,
                'options': options
            })
        
        parsed_questions[-1]['options'] = parsed_questions[-1]['options'][:-1]
        print(f'parsed_questions : {parsed_questions}')

        # Add parsed questions to the Canvas quiz
        for parsed_question in parsed_questions:
            question_text = parsed_question['text']
            options = parsed_question['options']

            # Construct the answer format for Canvas
            answers = []
            for option in options:
                weight = 100 if '[correct]' in option else 0
                option = option.replace('[correct]', '').strip()
                if ') ' not in option:  # Skip options without the specified delimiter
                    continue
                # Split by ') ' to separate option letter and text
                _, answer_text = option.split(') ')
                answers.append({
                    "answer_text": answer_text,
                    "weight": weight 
                })
            print(f'answers : {answers}')
            question_data = {
                "question": {
                    "question_name": "1 Question",
                    "question_text": question_text,
                    "question_type": "multiple_choice_question",
                    "points_possible": 1,
                    "answers": answers
                }
            }
            requests.post(f'{CANVAS_API_URL}courses/{COURSE_ID}/quizzes/{quiz_id}/questions', headers=headers_canvas, json=question_data)

        print('Down!')


app = App(app_ui, server, debug=True)
